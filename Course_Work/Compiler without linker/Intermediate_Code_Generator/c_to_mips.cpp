/*
    Translate syntax tree of a program to mips instructions
*/
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include <vector>
#include <memory>
#include <map>
#include <set>
#include <string>
#include "Lexer_Parser/Token.h"
#include "defines.h"
#include "Lexer_Parser/Program.h"

using std::shared_ptr;
std::string translate(std::shared_ptr<Program> root);
std::map<int, int> init_reverse_comparison_sign_map();
std::string translate_compound(std::shared_ptr<Compound> node);
std::map<std::string, std::string> label_blocks;

int count_label = 0; // Label format: L_n

std::string current_label; // string to store current label
int iden = 0; // number of identifiers
int cons = 0; // number of constants

std::map<std::string, std::string> identifiers; // map identifier -> address (in the form of offset)
std::set<std::string> visited; // check whether identifier has been assigned


// Generate a map to reverse comparison sign
std::map<int, int> init_reverse_comparison_sign_map() {
    std::map<int, int> reverse_comparison_sign;
    reverse_comparison_sign[GT] = LT;
    reverse_comparison_sign[GE] = LE;
    reverse_comparison_sign[LT] = GT;
    reverse_comparison_sign[LE] = GE;
    reverse_comparison_sign[EQ] = EQ;
    reverse_comparison_sign[NEQ] = NEQ;
    return reverse_comparison_sign;
}

/*
 * Function: std::string translate(std::shared_ptr<Program> root)
 *
 * Usage: Translate a syntax tree generated by a
 * C program and return the MIPS instructions as
 * a long std::string
 * -----------------------------------------------
 * The root object contains a vectors storing all its
 * functions. Every function contains vector storing a
 * set of instructions to be translated.
 */
std::string translate(std::shared_ptr<Program> root) {

    std::string mips; // string to store result

    // fetch blocks (of instructions) in a program
    std::vector<std::shared_ptr<Compound>> blocks = root->blocks;

    // interate on compound in blocks
    for (std::vector<std::shared_ptr<Compound>>::iterator it = blocks.begin(); it != blocks.end(); ++it) {
        mips += (*it)->func_name; // use function name as label
        mips += ":  ";
        mips+=translate_compound(*it); // translate instructions in function
    }

    std::string last_extra_label = "L_"+std::to_string(count_label)+":";
    mips+="sll $zero, $zero, 0"; // nop
    return mips;

}

/*
 * Function: std::string translate_compound(std::shared_ptr<Compound> node)
 *
 * Usage: Translate instruction blocks of a function
 * -----------------------------------------------
 * The parameter is a pointer pointing to a vector
 * storing all instructions in a function
 */
std::string translate_compound(std::shared_ptr<Compound> node) {
    using std::static_pointer_cast;

    std::string func_name = node->func_name;
    std::string mips;
    // vector of operators (instructions)
    std::vector<std::shared_ptr<Operator>> instrs = node->Children;
    // iterate on instruction set
    for (std::vector<std::shared_ptr<Operator>>::iterator it = instrs.begin(); it != instrs.end(); ++it) {

        std::shared_ptr<Operator> node = *it;

        shared_ptr<Statement> lnode0 = node->left;
        shared_ptr<Statement> rnode0 = node->right;
        // if reaches the end
        if(node->type==END) {
            // std::cout<<mips<<std::endl;
            return mips;
        }
        // if it is assignment (int a =...)
        else if(node->type==ASSIGNMENT) {
                // LHS is a variable
                auto lnode = static_pointer_cast<Variable>(lnode0);

                std::string lid_name = (lnode->name); // read identifier name
                std::stringstream lid_addr; // address of LHS var
                // a = 1
                // if RHS is an constant
                if (rnode0->type==NUM) {
                    auto rnode = static_pointer_cast<Number>(rnode0);
                    int val = rnode->value;
                    // RHS value
                    std::stringstream val_lo16, val_hi16;
                    val_lo16 << (val & 0xffff); // lower 16 bits
                    val_hi16 << (val >> 16); // higher 16 bits

                    // load value to LHS var address
                    mips+="lui  $s0, "+val_hi16.str()+"\n"+"ori  $s0, $s0, "+val_lo16.str()+"\n";
                }
                // a = b
                // if RHS is an identifier
                else if (rnode0->type==ID) {
                    // fetch RHS identifier
                    auto rnode = static_pointer_cast<Variable>(rnode0);
                    std::string rid_name = rnode->name; // RHS var name
                    std::string rid_addr = identifiers[rid_name]; // RHS var address
                    mips+="lw  $s0, "+rid_addr+"\n";

                }
                //////////
                // ADD ///
                //////////
                // a = x + y
                else if(rnode0->type==PLUS) {
                    mips+=translate_ADD(rnode0, identifiers);
                }
                //////////
                // SUB ///
                //////////
                // a = x - y
                // Note: MIPS use addiu to implement sub immediate
                else if(rnode0->type==MINUS) {
                    mips+=translate_SUB(rnode0, identifiers);
                }

                //////////
                // MULT //
                //////////
                // a = x * y
                else if(rnode0->type==MUL) {
                    mips+=translate_MULT(rnode0, identifiers);
                }

                //////////
                // DIV  //
                //////////
                // a = x * y
                else if(rnode0->type==DIV) {
                    mips+=translate_DIV(rnode0, identifiers);
                }

                // if a is newly delared, save address in map
                if (  visited.find(lid_name)==visited.end()  ) {
                    visited.insert(lid_name);
                    iden++;
                    lid_addr << iden * 4 << "($fp) ";
                    identifiers[lid_name] = lid_addr.str();
                }

                // save value in memory
                mips+="sw  $s0, "+identifiers[lid_name]+"\n";
            }
        //////////
        //  IF  //
        //////////
        // if (a<1) {...}
        else if(node->type==IF) {
            count_label++;
            mips+=translate_IF(node, identifiers, count_label);
            mips+="L_"+std::to_string(count_label)+":";
            mips+="sll $zero, $zero, 0\n"; // nop
        }
        ///////////
        // WHILE //
        ///////////
        // if (a<1) {...}
        else if(node->type==WHILE) {
            count_label++;
            mips+="L_"+std::to_string(count_label)+":";
            count_label++;// label in while condition is target at next label
            mips+=translate_WHILE(node, identifiers, count_label);
            mips+="L_"+std::to_string(count_label)+":";
        }
        /////////////////////
        //    PRINT CMD    //
        /////////////////////
        else if(node->type==PRINTF) {

            // syscall code for print is 1
            mips+="lui $v0, 0";
            mips+="ori $v0, 1";

            int val;

            std::stringstream val_lo16, val_hi16;

            shared_ptr<Statement> rnode = node->right;

            if (rnode->type == ID) {
                auto var_node = static_pointer_cast<Variable>(rnode);
                val = var_node->IDvalue;
            }
            else if (rnode->type == NUM) {
                auto num_node = static_pointer_cast<Number>(rnode);
                val = num_node->value;
            }
            else {
                std::cout<<"printf type error. Type code:"<<rnode->type<<std::endl;
                return mips;
            }

            val_lo16 << (val & 0xffff); // lower 16 bits
            val_hi16 << (val >> 16); // higher 16 bits

            mips+="lui $v0, "+val_hi16.str()+"\n";
            mips+="ori $v0, "+val_lo16.str()+"\n";

            mips+="syscall";
        }
    }

    return mips;
}

